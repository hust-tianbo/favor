# 链表

21.合并两个有序链表

双指针法，指针顺序往后移动





*<u>160.相交链表</u>*

**双指针，分别走完自己链表再走另一个链表（ACBC & BCAC）**



141.环形链表

双指针，快慢指针，如果是环形链表，则一定会相遇



206.反转链表

迭代：上一个的最后节点，当前节点

递归：每个部分长度的链表 得到 首节点和尾节点，再进行递归



*<u>234.回文链表</u>*

* 先用快慢指针找出中间节点

* 从中间节点开始反转链表
* 两个链表顺序比较是否完全相等



2.两数相加

注意要考虑进位情况



*<u>148.排序链表</u>*

* 先通过快慢指针找出中间节点
* 递归两个子链
* 合并两个有序子链，成为一个最终链



19.删除链表的倒数第N个节点

找出第N个节点，然后两个指针顺序往后移，直到最后一个节点



# 二叉树

617.合并二叉树

递归合并



104.二叉树的最大深度

广度优先求最大深度，递归解决



543.二叉树的直径

计算左右子树的深度，两个子树深度的总和+1等于树的直径，递归解决



26.翻转二叉树

递归解决翻转左右子树





101.对称二叉树

递归解决



96.不同的二叉搜索树

动态规划，以(0,N)为范围，当节点m为根节点时，共有(0,m)*(m,N)种可能。



114.二叉树展开为链表

递归解决，展开成链表



94.二叉树的中序遍历

递归



*<u>236.二叉树的最近公共祖先</u>*

* 如果左右树都能返回非空节点，说明是最近公共祖先
* 如果只有一颗子树返回非空，那么说明是最近公共祖先的根节点，直接返回即可



538.把二叉搜索树转换为累加树

先右节点->当前节点->左节点的顺序遍历



98.验证二叉搜索树

先转成中序遍历，再看中序遍历的数组是否有序



*<u>22.括号生成</u>*

回溯DFS遍历





*<u>105.从前序和中序遍历序列构造二叉树</u>*

分析前序和中序的规则，拆分出左子树和右子树，递归求解。





# map

1.两数之和

求解1：一遍哈希求解

求解2：sort之后，双指针遍历





49.字母异位词分组

先字符串排序后，排序相同的组成一个数组



253.会议室2





# 数组

*<u>461.汉明距离</u>*

异或操作，然后计算所有位为1的位数



*<u>136.只出现一次的数字</u>*

异或，得到出现一次的数字



169.多数元素

相同元素加1，不同元素减1



<u>*448.找到所有数组中消失的数字*</u>

不停的置换元素，直到元素已经存在过，再遍历一次，检查不存在的数字



155.最小栈

设计两个栈，正常元素栈和最小栈



20.有效括号

栈



# 调度

*<u>621.任务调度器</u>*

遍历所有可调度的任务，优先调度任务次数多的



# 下一个排列

*<u>31.下一个排列</u>*

先找出第一个非递增的数字，然后找出比该数字最接近的一个数字，进行置换



# DFS

200.岛屿数量

dfs。深度优先，找出所有不相隔的岛屿数量



79.单词搜索

dfs。深度优先



# LRU缓存

*<u>146.LRU缓存机制</u>*

map+双向链表



# 二分查找

*<u>34.在排序数组中查找元素的第一个和最后一个位置</u>*

二分查找，找前后两个相等值的下标



<u>*33.搜索旋转排序数组*</u>

二分查找，在哪些情况下需要往左走，哪些情况需要往右走





# 双指针

283.移动零

直接将非零的往前移动即可



*<u>11.盛最多水的容器</u>*

直接剪枝即可，双指针直接一遍遍历即可



*<u>75.颜色分类</u>*

双指针，第一个指针代表0的位置，第二个指针代表2的位置，然后遍历



<u>*581.最短无序连续子数组*</u>

双指针，找到左右边界

* 左边界，最左边的，大于后面最小值的点
* 右边界，最右边的，小于前面最大值的点



# 数组

*<u>238.除自身以外数组的乘积</u>*

每个元素拆成前后两段，前后两段可以遍历一遍得到



240.搜索二维矩阵2

类似二分查找，剪枝



287.寻找重复数

方式1：类似链表中的环结构

方式2：调整结构，直至找到有相同值的



15.三数之和

类似两数之和



# 贪心

55.跳跃游戏

动态规划即可



# 回溯

17.电话号码的字母组合

回溯，深度优先即可



46.全排列

回溯



39.组合总和

回溯



78.子集（需要额外看看）

回溯，dfs



# 位运算

338.比特位计数

找规律其实可以解决



# 单调栈和栈

739.每日温度（可以额外看看）

用栈解决



*<u>394.字符串解码</u>*

用栈解决





# 排序

*<u>215.数组中的第K大最大元素</u>*

最大的topK的小顶堆





347.前K个高频元

小顶堆



# 前缀和

*<u>560.和为K的子数组</u>*

转换成从0开始的累加和的差值



# 字典树

*<u>208.实现Trie*</u>

以字符组成数组



# DP

## 完全背包

70.爬楼梯

简单dp



<u>*322.零钱兑换*</u>

完全背包求解方式



*<u>279.完全平方数</u>*

完全背包求解方式



## 最大子序

53.最大子序和

动态规划



152.乘积最大子数组

动态规划



*<u>300.最长递增子序列</u>*

动态规划



## 看当前位置的上方和左方

*<u>221.最大正方形</u>*

动态规划



62.不同路径

动态规划



64.最小路径和

动态规划



## 01背包

<u>*416.分割等和子集*</u>

转换成01背包



<u>*494.目标和*</u>

1.使用迭代的方式求解

2.使用动态规划的方式求解



## 买卖股票

121.买卖股票的最佳时机



## 打家劫舍

198.打家劫舍



337.打家劫舍2



3.无重复字符的最长子串



<u>*4.寻找两个正序数组的中位数*</u>

注意截断，直到找到对应元素



*<u>297.二叉树的序列化和反序列化</u>*





*<u>239.滑动窗口最大值</u>*



